# Vulnerability routes
from fastapi import APIRouter, Depends, HTTPException, status
from typing import List, Optional
from config.database import get_database
from middleware.auth import get_current_user
from utils.jwt import TokenData
from schemas.vulnerability import Vulnerability, VulnerabilitySeverity

router = APIRouter(prefix='/vulnerabilities', tags=['Vulnerabilities'])

@router.get('', response_model=List[Vulnerability])
async def get_vulnerabilities(
    repository_id: Optional[str] = None,
    severity: Optional[VulnerabilitySeverity] = None,
    status: Optional[str] = None,
    current_user: TokenData = Depends(get_current_user),
    db = Depends(get_database)
):
    """Get vulnerabilities with optional filters"""
    # Get user's repositories
    user_repos = await db.repositories.find({'user_id': current_user.user_id}, {'_id': 0, 'id': 1}).to_list(1000)
    repo_ids = [r['id'] for r in user_repos]
    
    # Build query
    query = {'repository_id': {'$in': repo_ids}}
    if repository_id:
        query['repository_id'] = repository_id
    if severity:
        query['severity'] = severity.value
    if status:
        query['status'] = status
    
    vulns = await db.vulnerabilities.find(query, {'_id': 0}).to_list(1000)
    # Ensure owasp and cwe are always lists for Pydantic validation
    for v in vulns:
        if isinstance(v.get('owasp'), str):
            v['owasp'] = [v['owasp']]
        if isinstance(v.get('cwe'), str):
            v['cwe'] = [v['cwe']]
    return [Vulnerability(**v) for v in vulns]

@router.get('/{vuln_id}', response_model=Vulnerability)
async def get_vulnerability(
    vuln_id: str,
    current_user: TokenData = Depends(get_current_user),
    db = Depends(get_database)
):
    """Get a specific vulnerability by ID"""
    vuln = await db.vulnerabilities.find_one({'id': vuln_id}, {'_id': 0})
    if not vuln:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail='Vulnerability not found')
    
    # Verify ownership
    repo = await db.repositories.find_one({'id': vuln['repository_id'], 'user_id': current_user.user_id})
    if not repo:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail='Access denied')
    
    # Ensure owasp and cwe are always lists for Pydantic validation
    if isinstance(vuln.get('owasp'), str):
        vuln['owasp'] = [vuln['owasp']]
    if isinstance(vuln.get('cwe'), str):
        vuln['cwe'] = [vuln['cwe']]
    
    return Vulnerability(**vuln)

@router.patch('/{vuln_id}/status')
async def update_vulnerability_status(
    vuln_id: str,
    new_status: str,
    current_user: TokenData = Depends(get_current_user),
    db = Depends(get_database)
):
    """Update the status of a vulnerability"""
    vuln = await db.vulnerabilities.find_one({'id': vuln_id}, {'_id': 0})
    if not vuln:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail='Vulnerability not found')
    
    # Verify ownership
    repo = await db.repositories.find_one({'id': vuln['repository_id'], 'user_id': current_user.user_id})
    if not repo:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail='Access denied')
    
    await db.vulnerabilities.update_one(
        {'id': vuln_id},
        {'$set': {'status': new_status}}
    )
    
    return {'status': 'updated'}
